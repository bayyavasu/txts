multitasking:
Executing serveral tasks simultaneously is the concept of multi tasking. There are 2 types of multi tasking
1.Process based multi tasking.
2.Thread based multitasking.

1.Process based milti tasking:
Executing serveral tasks simultaneously where each task is a separate independent program(process) is called Process based multitasking. 
ex:while typing a java program in the editor we can listen audio songs from the same system.yet the same time we can download a file from net all these tasks will be executed simultaneously under indepenndent of each other.hence, it is process based multitasking. Process based multi tasking is best suitable at OS level.

2.Thread based multitasking: 
Executing serveral tasks simultaneously where each task is a separate independent part of the same program is called Thread based multitasking and each independent part is called a thread.Process based multi tasking is best suitable at programatic level.
Advantage of MultiTasking:

Whether it is process based or thread based the main objective of multitasking is to reduce reponse time of the system and to improve performance.(Instead of doing tasks one by one doing tasks simultaneously).
The main important application areas of multi threading are
1. To develop multimedia graphics 
2. To develop animations.
3. To develop video games
To develop web servers and application servers etc.,   


Thread : A independent job of a program.
Defining a thread: we can define a thread in the following 2 ways:
1.  By extending thread class.
2.  By implementing runnable interface.

1.  By extending thread class:
----------------------------------main thread-------------------------------------
public class MainThread {
public static void main(String[] args) {
	MyThread myThread  = new MyThread();
	myThread.start();
	for(int i=0 ;i<6;i++)                       --------- executed by main thread
		{
			System.out.println(i);
		}
}
}
---------------------------------child thread----------------------------------------
public class MyThread extends Thread{

	@Override
	public void run() {
		// TODO Auto-generated method stub
		for(int i=0 ;i<6;i++)                       --------- executed by child thread
		{
			System.out.println("child thread"+i);
		}
		super.run();
		
		
}	}
----------------------------------------
Java provides inbuilt support for multi threading with rich API (Thread,Runnable,ThreadGroup ... )
Differnece between t.start() and t.run()



                Thread scheduler:
It is the part of the JVM .It is responsible to shedule threads ie., if multiple threads are waiting to get the chance of execution
then in which order threads will be executed is decided by thread scheduler.
we cannot expect exact algorithm followed bythread scheduler(may be first come first serve,shortest job first,round robin algorith). it is varied from JVM to JVM hence we can't expect threads execution order and exact output.
Hence whenever situation comes to multi threading there is no guarentee for exact output but we can provide several possible outputs.
possibility--1
main thread 
child thread
-------------
possibility--2
child thread 
main thread
-------------
possibility--3
child thread 
main thread
child thread 
--------------------------------------------------------------------
If the t.start() is called then a new  thread will be created and that thread will be responsible for the execution of run().
but in the case of t.run() a new thread won't be created and the run() will  be executed jst like a normal method call by main thread. hence in the above program if we replace t.start() with t.run() then the output is childthred 10 times followed by main thread 10 times. This total output produced by only main thread.

	
Importance of start() :

to register the thread with thread scheduler and all other mandatory activities
hence without executing thread.start() there is no chance of starting a new thread in java due to this thread class start method is considered as heart of multithreading
1.	Register this thead with thread scheduler
2.	perform all other madatory activities 
3.	invoke run method

	case-4	
OverLoading of run() is always possible but thread.start() can invoke no-args run method
The other overloaded run(int i) method we have to call exlicitily like a normal method call.
--------------
case-5:
If we are not overriding run method : then thread class run() will be executed which has empty implementation hence we wont get 
any output.
ex:
class myThread extends Thread{
	
}
class test{
	myThread  t = new myThread();
	t.start();
}
The above program is correct but the output is empty because the thread class have empty run method.
it is highly recommended to override run method.otherwise dont go for  threads.
-----------
overriding of start(): if we override start() then ou start method will be executed just like a normal method call and new thread 
wont be created.we are not giving the chance to call the super class start method.
total output produced by main thread.
it is not recommended to overridde start method otherwise dont go for multi threading.
class myThread extends Thread{
	public void start() {
		for(int i=0 ;i<6;i++)                       
		{
			System.out.println("start method");
		}
	@Override
	public void run() {
		// TODO Auto-generated method stub
		for(int i=0 ;i<6;i++)                       
		{
			System.out.println("child thread");
		}
	}
}
class test{
	myThread  t = new myThread();
	t.start();
	System.out.println("main thread");
}
-----------------------
class myThread extends Thread{
	public void start() {
		// TODO Auto-generated method stub
		for(int i=0 ;i<6;i++)                       
		{
			super.start(0);
			System.out.println("start method");
		}
	@Override
	public void run() {
		// TODO Auto-generated method stub
		for(int i=0 ;i<6;i++)                       
		{
			System.out.println("child thread");
		}
	}
}
class test{
	myThread  t = new myThread();
	t.start();
	System.out.println("main thread");
}
---------------------------------------
Thread Life Cycle:
	myThread  t = new myThread(); -----------> new/born state
	t.start();        ----------->runnable or ready state
	if Thread scheduler allocates processor -----------> running state
	if run method completes     -----------> dead state

	
	
-------------------------------------3----------------------------------------
we can define a thread by implementing runnable interface
class  Thread implements runnable{

}
Thread mythread implements runnable{

}
Runnable interface present in java.lang package and it contains only one method "public void run()"
class myRunnable implements Runnable{
	public void run()
	{
		for(int i=0;i<5;i++)                                     
		{ 
			System.out.println("child "+i);
		}
	}
}
public class main()
{
	public static void main(String args[])
	{
		myRunnable r = new myRunnable();
		Thread thread = new Thread(r);         ----------> Here r is target runnable
		thread.start();
	}
}
we will get mixed output and we cant tell exact output.
case Study:
		myRunnable r = new myRunnable();
		Thread thread1 = new Thread(); 
		Thread thread2 = new Thread(r);
	case-1:thread1.start() ---->  A new thread will be created which is responsible for  the execution of thread class run(), which
	has empty implementation.
	case-2:thread1.run()  -----> No new thread will be  created and thread class run method will be executed just like a normal method call.
    case-3:thread2.start()  ----> A new thread will be created which is responsible for thr execution of myRunnable class run().
	case-4:thread2.run()  -----> A new thread wont be created and myRunnable run() will  be executed just like a normal method call.
    case-5:r.start() ----> we will get compile time error saying myRunnable class doesnt have start capability.
	    error: cannot find symbol method start() in location class runnable.
    case-6:r.run() ----> No new thread will be created and myRunnable run() will be executed like normal method call.
which approach is  best to define a thread ???
Among 2 ways of defining a thread implements runnable approach is  recommended.
In the first approach our class always extends thread class , there is no chance of extending any other class.
Hence,we are missing inheritance benefit. But in the second approach while implementing runnable interface we can extend any other class.
hence we wont miss any inheritance benefit.
Because of above reason implemeting runnable interface approach is recommended than extending thread class. 


Thread Class contructors:
  1.Thread thread = new Thread();
  2.Thread thread = new Thread(r);
  3.Thread thread = new Thread(String name);
  4.Thread thread = new Thread(Runnable r,String name);
  5.Thread thread = new Thread(ThreadGroup group,String name)
  6.Thread thread = new Thread(ThreadGroup group,Runnable r);
  7.Thread thread = new Thread(ThreadGroup group,Runnable r,String name);
  8.Thread thread = new Thread(ThreadGroup group,Runnable r,String name,Long stackSize);

Durgas approach to craete a thread(not recommended to use):

class MyThread extends Thread{
	public void run()
	{
		for(int i=0;i<5;i++)
		{
			System.out.println("childd thread"+i);
		}
	}
} 
class main{
	public static void main(String args){
		MyThread mythread = new MyThread();
		Thread t1 = new Thread(mythread);
		t1.start();
		System.out.println("main thread");

	}
}
-------mixed output---------
-------------------------4---------------------------
Getting and Setting name of a thread:
Every Thread in java has some name. It may be default name generated by JVM or customized name provided by programmer.
we can get and set name of a thread by using the following 2 methods of thread class.
public final String getName()
public final void setName(String name)
Thread.currentThread.setName("some name");
Thread.currentThread.getName();

Every Thread in java has some priority it may be default priority generated by jvm or customized priority provided by programmer.
The valid range of thread priorities is 1 to 10. Where 1 is MIN_PRIORITY and 10 is MAX_PRIORITY.
Thread class defines the following constants to represent some standard priorities.
  Thread.MIN_PRIORITY =1
  Thread.NORM_PRIORITY =5
  Thread.MAX_PRIORITY =10
Thread scheduler will use priorities while allocating processor.
The Thread which is having highest priority will get chance first.
if threads having same priority then we cant expect exact execution order.
It depends on thread scheduler.
Thread class defines the following methods to get and set priority of a thread.
public final int getPriority();
public final int setPriority(int p);
Allowed values range 1 to 10. Otherwise RunTimeException: IllegalArguementE	xception.
t.setPriority(7);  ----> valid 
t.setPriority(17);  -----> invalid  IllegalArguementException.
Default Priority: 
The default priority only for the main thread is 5.
But for all the remaining threads default priority will be inherited from parent to child.
Whatever priority parent thread has the same priority will be there for the child thread.

Example:
class mythread extends Thread{
	public void run()
	{
		for(int i=0;i<5;i++)
		{
			System.out.println("child thread"+i);
		}
	}
}
class main{
	public static void main(String args){
		MyThread mythread = new MyThread();
		Thread t1 = new Thread(mythread);
		t1.setPriority(10);
		t1.start(); 
     for(int i=0;i<5;i++)
		{
			System.out.println("main thread"+i);
		}}
in the above example child thread will be executed first because child thread has high priority(10) where as main thread has normal priority(5)
if we comment line t1.setPriority(10); then we will get mixed output.
--------------------------------------------------5555555--------------------------------------------------------
We can prevent thread execution by  using the following methods
1. yield()
2. join()
3. sleep()

1.  yield():
yield() causes to pause the current executing thread to give the chance for waiting threads of same priority.
If there is no waiting thread or  all waiting threads have low priority then same thread can continue its execution.
if multiple threads are waiting with same priority then which waiting thread will get the chance? we can't expect it depends on thread scheduler.
the thread which is yielded when it will get the chance once again it depends on thread scheduler and we cant expect exactly.
    public static native void yield();                 
	                                                     Thread.yield();
                                                 --------------------------------------
                                                |                                      | 
                          t.start()             \/           if thread scheduler       |       run() method
      new myThread();  ---------------->  ready/runnable state-------------------------> running state-------------------->   dead state
     new/born state                                        allocates processor                  completes



Example:
class mythread extends Thread{
	public void run()
	{
		for(int i=0;i<5;i++)
		{
			System.out.println("child thread"+i);
			Thread.yield();
		}
	}
}
class main{
	public static void main(String args){
		MyThread mythread = new MyThread();
		Thread t1 = new Thread(mythread);
		t1.setPriority(10);
		t1.start(); 
     for(int i=0;i<5;i++)
		{
			System.out.println("main thread"+i);
		}}
  If we are commenting Thread.yield(); the both the threads will be executed simultaneously and we cant expect whicch thread will complete first.
  If we are not commenting Thread.yield(); then child thread always calls yield method  because of that main thread will get chance more number of times
	 and the chance of completing main thread first is high.
  some platforms wont provide proper support for yield method.

2. join()
    public static void join();
  If a thread wants to wait until completing some other thread then we should go for join(). 
  For example if a thread t1 wants to wait until completing t2 then t1 has to call t2.join().
  If t1 executes t2.join() then immediately t1 will be entered into waiting state until t2 completes.
  Once t2 completes then t1 can continue its execution.
  venue fixing activiti                     wedding cards printing                           wedding cards distribution
        (t1)                                         (t2)                                               (t3)
          |                                            |                                                 | 
		  |                                            t1.join();                                        t2.join();
		                                               |                                                 |

public final void join() throws InterruptedException

public final void join(long milliseconds) throws InterruptedException

public final void join(long milliseconds,int nanoseconds) throws InterruptedException
----------------------------------------------66666666666666-------------------------------------
Every join method  throws interrupted exception which is checked exception hence compulsory we should handle this exception either by using 
try catch or by throws keyword otherwise we eill get compile time error.
	                                                  
											1.	when t2 is completed
											2.	if time given for t2 expires	                 
											3.  if waiting thread got 
											    interrupted			 t2.join(); or t2.join(1000); or t2.join(1000,100);  
                                                 -------------------waiting state-------
                                                |                  blocked for joining |
												|                                      | 
                          t.start()             \/           if thread scheduler       |       run() method
      new myThread();  ---------------->  ready/runnable state----------------------> running state-------------------->   dead state
     new/born state                                        allocates processor                  completes
case 1: Waiting of main Thread until completing of child thread 

Example:
class mythread extends Thread{
	public void run()
	{
		for(int i=0;i<5;i++)
		{
			System.out.println("seetha thread"+i);
			try{
			Thread.sleep(2000);
			}catch(InterruptedException e)
			{
				e.printStackTrace();
			}
		}
	}
}
class main{
	public static void main(String args){
		MyThread mythread = new MyThread();
		Thread t1 = new Thread(mythread);
		t1.setPriority(10);
		t1.start(); 
		t1.join(); 
     for(int i=0;i<5;i++)
		{
			System.out.println("rama thread"+i);
		}}
  
If we comment t1.join() then both main and child thread will be executed simultaneously and we cannot expect exact output.
If we are not  commenting  t1.join() then main thread calls  join method on child thread object hence main thread will wait until completing child thread
in this case output is seetha thread 10 times and rama thread 10 times.

case 2:
waiting of child thread until completing main thread.


Example:
class Mythread extends Thread{
  static Thread mt;
	public void run()
	{
		
			try{
			mt.join();
			}catch(InterruptedException e)
			{
				e.printStackTrace();
			}
			 for(int i=0;i<5;i++)
		{
			System.out.println("seetha thread"+i);
		}
		}
	}
}
class main{
	public static void main(String args) throws {
		MyThread mythread = new MyThread();
		Mythread.Thread = Thread.currentThread();
		Thread t1 = new Thread(mythread);
		t1.setPriority(10);
		t1.start(); 
     for(int i=0;i<5;i++)
		{
			System.out.println("rama thread"+i);
		}}
In the above example child thread calls join method on main thread object hence child thread has to wait until completing main thread.
in this case  output is rama thread 10 times and seetha thread 10 times.

case 3:
If main thread calls join method and child thread calls join metthod on main thread object then both threads will wait forever  and the program will be 
strucked or pauesed (this is something like deadlock).
Example:
class Mythread extends Thread{
  static Thread mt;
	public void run()
	{
		
			try{
			mt.join();
			}catch(InterruptedException e)
			{
				e.printStackTrace();
			}
			 for(int i=0;i<5;i++)
		{
			System.out.println("seetha thread"+i);
		}
		}
	}
}
class main{
	public static void main(String args) throws {
		MyThread mythread = new MyThread();
		Mythread.Thread = Thread.currentThread();
		Thread t1 = new Thread(mythread);
		t1.setPriority(10);
		t1.start(); 
		t1.join();
     for(int i=0;i<5;i++)
		{
			System.out.println("rama thread"+i);
		}}
case 4: If a thread calls join() on a same thread itself then the program will be strucked. this is something like deadlock.in this case thread has to wait 
infinite amount of time.
Example:
class Test()
{
		public static void main(String args) throws  InterruptedException{
			Thread.currentThread.join();

}

sleep():
If a thread dont want to perform any operatoin for a particular period of time then it should go for sleep method.
public static native void  sleep(long ms)throws  InterruptedException
public static void sleep(long ms,int ns)throws  InterruptedException
every sleep() throws interrupted exception hence, which is checked exception hence, whenever we are using sleep() compulsary we should handle
InterruptedException either by try catch or by throws keyword otherwise we will  get compile time error.
	                                                  
											1.	when sleep time is completed
											2.  if sleeping thread got 
											    interrupted			 Thread.sleep(1000); or Thread.sleep(1000,100);  
                                                 -------------------waiting state-------
                                                |                  blocked for joining |
												|                                      | 
                          t.start()             \/           if thread scheduler       |       run() method
      new myThread();  ---------------->  ready/runnable state----------------------> running state-------------------->   dead state
     new/born state                                          allocates processor                  completes
Example:
class SlideRotator()
{
		public static void main(String args) throws  InterruptedException{
 for(int i=0;i<5;i++)
		{
						System.out.println("Slide "+i);
						Thread.sleep(5000);
		}
}

How a Thread can interrupt another thread.
A thread can interrupt a sleeping thread or waiting thread by using interrupt() of thread class.
public void interrupt()
class MyThread extends 	Thread{
	public void run()
	{
		try{
			for(int i=0;i<10;i++)
		{
			System.out.println("I am a lazy thread");
            Thread.sleep(2000);
		}
		}
		catch(InterruptedException e)
		{
			System.out.println("I got interrupted");
			e.printStackTrace();
		}
	}
}
public 	ThreadInterruption
{
	public statc void main(String args[])
	{
		MyThread myThread = new MyThread();
		myThread.start();
		myThread.interrupt();
		System.out.println("end of  thread");
	}
}
If we comment 	myThread.interrupt() then  main Thread wont interrupt child thread in this case child thread will execute for loop 10 times.
If we not commenting myThread.interrupt() then main thread interrupts child thread in this case output is 
1. end of  thread
2. I am a lazy thread
3. I got interrupted

**Note: whenever we are calling interrupt() if the target thread is not in sleeping state or waiting then there is no impact of interrupt call immediately.
interrupt call will be waited until target thread entered into sleeping or waiting  state.
If the target thread is entered into sleeping or waiting state then immediately interrupt call will interrupt the target thread.
If the targte thread never entered into sleeping or waiting state in its lifetime then there is no impact on interrupt call. This is the only case where
interrupt call is wasted

class MyThread extends 	Thread{
	public void run()
	{
	 for(int i=0;i<10000;i++)
		{
		System.out.println("child thread "+i);
		}	
			System.out.println("I am going to sleep");

		try{
		
            Thread.sleep(2000);
		
		}
		catch(InterruptedException e)
		{
			System.out.println("I got interrupted");
			e.printStackTrace();
		}
	}
}

public 	ThreadInterruption
{
	public statc void main(String args[])
	{
		MyThread myThread = new MyThread();
		myThread.start();
		myThread.interrupt();
		System.out.println("end of  thread");
	}
}
	In the above example interrupt calll waited until  child thread completes for loop 10000 times.

	Comparision Table of yield(), join() and sleep()

	property                              yield                                          join                                     sleep
	purpose?             if a  thread wants to pass its execution          if a  thread wants until completing        if a thread dont want to perform any 
	                     to give the chance for remaining threads of       some other thread then it shoul call        operation for particular period of time
						 same Priority then we should go for yield()         join()                                    then we should call sleep()
	                    
    is it overloaded                       No                                                                                                                                                       sleep(llong ms,int ns)-----> non nativeYes                                     Yes
	is it final                            no                                              yes                                     No
	is it throws InterruptedException      No                                              Yes                                     yes
	is it native                           yes                                             No                                    sleep(long ms); --->natiiv
	                                                                                                                           sleep(llong ms,int ns)-----> non native
	is it static 							Yes                                             no                                     yes				

--------------------------------------------------------77777777777777----------------------------------
Synchronization 
	Synchronized is the modifier applicable only for methods and blocks but not for classes and variables.
	if multiple threads are trying to operate simultaneously on the same java object then there may be a chance of data inconsistency problem.	
	To overcome this problem we should go for Synchronized keyword.
	if a method or block declared as Synchronized then at a time only one thread is allowed to execute that method or block on the given object.
	so that data inconsistency problem wil be resolved.			
	The main Advantage of Synchronized keyword is we can resolve data inconsistency problems.
	but the main disadvantage of Synchronized keyword is  it incrases waiting time of threads and creates performance problems.Hence, if there is no 
	specific requirement then it is not recommended to use Synchronized keyword.	
Internal working:	
	Internally Synchronization is implemented by using lock. Every object inn java has a unique lock.
	whenever we are using Synchronized keyword then only lock concept will come into the picture.
	If a thread wants to execute Synchronized method on the given object first it has to get lock of that object. 
	Once thread  got the lock then it is allowed to execute ant Synchronized method on that object.
	Once method execution completes automatically thread releases lock.
	Acquiring and releasing lock Internally takes care by JVM and programmer not responsible for this activity.
	While a thread executing Synchronized method on the given object the remaining threads are not allowed to execute any Synchronized method 
	simultaneously on the same object.
	But remaining threads are allowed to execute non Synchronized methods simultaneously.
	lock concept is implemented based on object but not based in method.

               	--------------------------------
               	| Non         |  Synchronized  | 
                |Synchronized |      area      |
               	| area        |                |
               	--------------------------------
This area can be accessed              This area can be accessed by only one thread(which having lock)
by any no of threads                    at a time
simultaneously	
				
Synchronized Area
{
	where ever we are performing update operation add/update/delete ie., where the state of object is changing 
}	
Non-Synchronized Area
{
	where ever we are performing read operation  ie., where the state of object is not changing 
}		
Example:
class Reservation{
	checkAvailability()   -----------> Non-Synchronized
	{

	}
	bookTicket()    -----------------> Synchronized
	{

	}
}

Synchronized Example:
class Display
{
	public Synchronized  void wish(String name)
	{
       for(int i=0;i<10;i++)
	   {
		System.out.println("Good morining :");
		try{
			Thread.sleep(2000);
		}catch(InterruptedException e)
		{
			e.printStackTrace();
		}
	   }
		System.out.println(name);

	}
}

class MyThread extends Thread
{
	Display d;
	String name;
	MyThread(Display d, String name)
	{
     this.d = d;
     this.name = name;
	}
	public void run()
	{
		d.wish(name);
	}
}

class SynchronizedDemo
{
	public static void main(String args[])
	{
		Display d =new Display();
		MyThread mythread1 = new Mythread(d,"Dhoni");
		MyThread mythread2 = new Mythread(d,"Kohli");
		MyThread mythread3 = new Mythread(d,"yuvraj"); 
       mythread1.start();
	   mythread2.start();
	    mythread3.start();

	}
}

When the wish method is Synchronized then wish method can be used only by one thread at a time.that causes regular output.
When the wish method is not Synchronized then wish method can be used by any thread. that causes mixed and irregular output.

-----------------------------8888888---------------------------------------
case study:
class SynchronizedDemo
{
	public static void main(String args[])
	{
		Display d1 =new Display();
		Display d2 =new Display();

		MyThread mythread1 = new Mythread(d1,"Dhoni");
		MyThread mythread2 = new Mythread(d2,"Kohli");
       mythread1.start();
	   mythread2.start();

	}
}
Eventhough wish() is Synchronized we will get irregular output because threads are operating on different java objects.
Reason:if multiple threads are operating on same java object then Synchronization is required 
 if multiple threads are operating on multiple java objects then Synchronization is not required.
mythread1 requires the lock of d1 object
mythread2 requires the lock of d2 object


                                Class Level Lock:
Every  class in java has a unique lock which is nothing but class level lock.
If a thread wants to execute a static Synchronized method then thread required class level lock.
once thread got class level lock then it is allowed to execute any static synchrinized method of that class.
once method execution completes automatically thread releases the lock.

class x{

	static synchronized m1(){}             ------------------->class level lock
    synchronized m1(){}                    ------------------->object level lock
	static  m1(){}                         -------------------> no lock required
	  m1(){}                               -------------------> no lock required

}
while as thread executing static synchrinized method the remaining threads are not allowed to execute any static Synchronized method simultaneously
But remaining threads are allowed to execute the following methods simultaneously.
1.normal static methods
2.Synchronized instance method.
3.normal instance method
class Display
{
	public   void wish(String name)
	{
       for(int i=0;i<10;i++)
	   {
		System.out.println("Good morining :");
		try{
			Thread.sleep(2000);
		}catch(InterruptedException e)
		{
			e.printStackTrace();
		}
	   }
		System.out.println(name);

	}
	public   void wish2(String name)
	{
       for(int i=0;i<10;i++)
	   {
		System.out.println("Good morining :");
		try{
			Thread.sleep(2000);
		}catch(InterruptedException e)
		{
			e.printStackTrace();
		}
	   }
		System.out.println(name);

	}
}

class MyThread extends Thread
{
	Display d;
	String name;
	MyThread(Display d, String name)
	{
     this.d = d;
     this.name = name;
	}
	public void run()
	{
		d.wish(name);
	}
}
class MyThread2 extends Thread
{
	Display d;
	String name;
	MyThread(Display d, String name)
	{
     this.d = d;
     this.name = name;
	}
	public void run()
	{
		d.wish2(name);
	}
}

class SynchronizedDemo
{
	public static void main(String args[])
	{
		Display d =new Display();
		MyThread mythread1 = new Mythread(d,"Dhoni");
		MyThread2 mythread2 = new Mythread(d,"Kohli");
       mythread1.start();
	   mythread2.start();
	}   ------------------------------------------->mixed  output(irregular output)
}
-------------------------------9999999--------------------------------------------------------------------------------------------
Synchronized Block
If very few lines of coderequires Synchronization  then it is not recommended to declare entire method as synchrinized.
we have to enclose those few lines of code by using  synchonized block.
The main advantage of synchronized block over synchronized method is it reduce waiting time of thread and improves performance of the system.
We can declare synchronized block as follows:
1.To get lock of current block:
synchronized(this)
{

}
If a thread got lock of current object then it is allowed to execute this area.

2.To get the lock of particular object.
synchronized(d)
{

}
If a thread got lock of particular object then it is allowed to execute this area.

2.To get the class level lock:
synchronized(Display.class)
{

}
If a thread got class level lock of Display class then only it is allowed to execute this area.
class Display
{
	public   void wish(String name)
	{
		//one lack lines of code
		synchronized(this)
       for(int i=0;i<10;i++)
	   {
		System.out.println("Good morining :");
		try{
			Thread.sleep(2000);
		}catch(InterruptedException e)
		{
			e.printStackTrace();
		}
	   }
   		System.out.println(name);
	}	
		//one lack line of code

	}
}

class MyThread extends Thread
{
	Display d;
	String name;
	MyThread(Display d, String name)
	{
     this.d = d;
     this.name = name;
	}
	public void run()
	{
		d.wish(name);
	}
}
class SynchronizedDemo
{
	public static void main(String args[])
	{
		Display d =new Display();
		MyThread mythread1 = new Mythread(d,"Dhoni");
		MyThread2 mythread2 = new Mythread(d,"Kohli");
       mythread1.start();
	   mythread2.start();
	}   ------------------------------------------->regular  output
}

Lock concept applicable for object  types and class types but not for primitives hence, we cant pass primitive types of arguement to synchronized block.
otherwise we eill get compile time error saying Unexcpected type.
Example:
int x=10;
synchronized(x)
{

}
exception: Unexcpected type
found : int
required: reference

FAQ 
	1. Synchronized keyword where we can apply?
	2.Advantages  of synchronized keyword. resolve data inconsistency problem
	3.explain disadvantages of synchronized keyword. increases waiting time of threads and creates performance problem
	4.what is Race condition? If multiple threads are operating  simultaneously on same java object then there may be a chance of data  inconsistency problem.This is called race condition.We can overcome this problem using synchronized keyword.
	5.What is object lock when it is required? whenever a thread wants to use synchronized method then 
	6.what is Differnece between class level lock and object level lock? 
	7.while a thread executing synchronized method on the given object is the remaining threads are allowed to execute any other synchronized method simultaneously on the same object?  No
	8.what is synchronized block andhow to declare?
	9.Advantage of synchronized block over synchronized method?
	10. Is a thread can acquire multiple locks simultaneously?    Yes from different objects
	class x{
		public synchronized void m1()
		{
			y y = new Y();
			synchronized(y)
			{
				Z z = new Z();
				Synchronized(z)
				{
					 
				}
			}

		}
	}
1.
Two threads can communicate wuth each other by using wait(), notify() ,notifyall() methods.
The thread which is expecting updation is responsible to call wait() then immediately the thread will enter into waiting state.
The Thread which is responsible to perform updation, after performing updation it is responsible to call notify() then waiting thread will 
get that notification  and continue its execution with those updated items.
2.
wait(), notify() ,notifyall() methods present in object class but not in thread class because thread can call these methods on
any java object.
3.
To call wait(), notify() ,notifyall() methods on any object, thread should be owner of that object. 
ie., the thread should have lock of that object ie., inside synchronized area. hence we can call notify() and notifyall() only from synchrinized area.
otherwise we will get RunTimeException saying IllegalMonitorStateException
If a thread calls wait() on any object it immediately releases the lock of that particular object and entered into waiting state.	
If a threads calls notify() on any object it releases the lock of that object but may not immediately. except wait(), notify() and notifyall()
there is no other method where thread releases lock.

       method                          is thread releases the lock
	   yield()                                No
	   join()                                 No
	   sleep()                                No
 	   wait()                                 Yes
	   notify ()                              Yes
	   notifyall()                            Yes
which of the following is valid?
1.	    the thread calls wait() immediately goes to wait() without releasing  lock.
2.if a thread calls wait() it releases the lock of that object but may not immediately.
3.If a thread calls wait() on any object it releases all locks acquired by that thread and immediately entered into waiting state.
4.  the thread calls wait()  on any object it immediately releases  lock and goes to wait() .----------------->correct
5. If a thread calls notify() on any object it immediately releases the lock of that particular object.
6.If a thread calls notify() on any object it releases the lock of that particular object but may  not immediately..
         public final void wait() throws InterruptedException
         public final native void wait(long milliseconds) throws InterruptedException
         public final native void wait(long milliseconds,int nanoseconds) throws InterruptedException
         public final void notify()
         public final void notifyall()
 Note: Every wait() throws InterruptedException which is checked exception hence whenever we are using wait() compulsary we
 should handle this InterruptedException either by try catch or throws keyword.
 Otherwise we will get compile time error.
 Producer COnsumer problem:
   producer thread is responsible to produce items to the queue.	
   and COnsumer thread is responsible to COnsume items from the queue.
   If Queue is empty then consumer thread will call wait() and entered into waiting  state.	 
   After  producing items into the queue producer thread is responsible to call notify() then waiting consumer will get that notification. and continue its execution with updated items.

   class ProducerThread
   {
	produce()
	{
		synchonize(q)
		{
				//produce ites to the queue
		q.notify();
		}
	}
   }|
    |
	|
  queue
    |
	|
	|
   class ConsumerThread
   {
	consume()
	{
		synchonize(q)
		{
		if(q is empty)
		{
			q.wait();
		}
			else
consume items		}
	}
   }

we can use notify() to give the notification for only one Waiting thread.
If multiple threads are waiting then only one thread will be notified and the remaining have to wait() for further notification.
Which thread will be notified we cannot expect it depends  on  JVM.
We can use notifyall() to give the notification for all waiting threads of  a particular object. 
Eventhough multiple threads notified but executing will be performed one by one because threads required lock. and only one lock
is available.
Note: On which object we are calling wait() thread requires lock of that object.
ex: if we are calling wait() on s1 then we have to call wait() on s1 then we have to get lock of s1 object.
but not s2 object.
-------------------------------------1212121212121212----------------------------------------------
If 2 threads are waiting for eachother forever such type of infinite waiting is called deadlock.