multitasking:
Executing serveral tassks simultaneously is the concept of multi tasking. There are 2 types of multi tasking
1.Process based multi tasking.
2.Thread based multitasking.
1.Process based milti tasking:
Executing serveral tasks simultaneously where each task is a separate independent program(process) is called Process based multitasking. 
ex:while typing a java program in the editor we can listen audio songs from the same system.yet the same time we can download a file from net all these tasks will be executed simultaneously under indepenndent of each other.hence, it is process based multitasking. Process based multi tasking is best suitable at OS level.
2.Thread based multitasking: 
Executing serveral tasks simultaneously where each task is a separate independent part of the same program is called Thread based multitasking and each independent part is called a thread.Process based multi tasking is best suitable at programatic level.
Advantage of MultiTasking:
Whether it is process based or thread based the main objective of multitasking is to reduce reponse timme of the system and to improve performance.(Instead of doing tasks one by one doing tasks simultaneously).
The main important application areas of multi threading are
1. To develop multimedia graphics 
2. To develop animations.
3. To develop video games
To develop web servers and application servers etc.,   


Thread : A independent job of a program.
Defining a thread: we can define a thread in the following 2 ways:
1.  By extending thread class.
2.  By implementing runnable interface.
1.  By extending thread class:
----------------------------------main thread-------------------------------------
public class MainThread {
public static void main(String[] args) {
	MyThread myThread  = new MyThread();
	myThread.start();
	for(int i=0 ;i<6;i++)                       --------- executed by main thread
		{
			System.out.println(i);
		}
}
}
---------------------------------child thread----------------------------------------
public class MyThread extends Thread{

	@Override
	public void run() {
		// TODO Auto-generated method stub
		for(int i=0 ;i<6;i++)                       --------- executed by child thread
		{
			System.out.println("child thread"+i);
		}
		super.run();
		
		
}	}
----------------------------------------
Java provides inbuilt support for multi threading with rich API (Thread,Runnable,ThreadGroup ... )
Differnece between t.start() and t.run()



                Thread scheduler:
It is the part of the JVM .It is responsible to shedule threads ie., if multiple threads are waiting to get the chance of execution
then in which order threads will be executed is decided by thread scheduler.
we cannot expect exact algorithm followed bythread scheduler(may be first come first serve,shortest job first,round robin algorith). it is varied from JVM to JVM hence we can't expect threads execution order and exact output.
Hence whenever situation comes to multi threading there is no guarentee for exact output but we can provide several possible outputs.
possibility--1
main thread 
child thread
-------------
possibility--2
child thread 
main thread
-------------
possibility--3
child thread 
main thread
child thread 
--------------------------------------------------------------------
If the t.start() is called then a new  thread will be created and that thread will be responsible for the execution of run().
but in the case of t.run() a new thread won't be created and the run() will  be executed jst like a normal method call by main thread. hence in the above program if we replace t.start() with t.run() then the output is childthred 10 times followed by main thread 10 times. This total output produced by only main thread.

	
Importance of start() :

to register the thread with thread scheduler and all other mandatory activities
hence without executing thread.start() there is no chance of starting a new thread in java due to this thread class start method is considered as heart of multithreading
1.	Register this thead with thead scheduler
2.	perform all other madatory activities 
3.	invoke run method

	case-4	
OverLoading of run() is always possible but thread.start() can invoke no-args run method
The other overloaded run(int i) method we have to call exlicitily like a normal method call.
--------------
case-5:
If we are not overriding run method : then thread class run() will be executed which has empty implementation hence we wont get 
any output.
ex:
class myThread extends Thread{
	
}
class test{
	myThread  t = new myThread();
	t.start();
}
The above program is correct but the output is empty because the thread class have empty run method.
it is highly recommended to override run method.otherwise dont go for  threads.
-----------
overriding of start(): if we override start() then out start method will be executed just like a normal method call and new thread 
wont be created.we are not giving the chance to call the super class start method.total output produced by main thread.
it is not recommended to overridde start method otherwise dont go for multi threading.
class myThread extends Thread{
	public void start() {
		// TODO Auto-generated method stub
		for(int i=0 ;i<6;i++)                       
		{
			System.out.println("start method");
		}
	@Override
	public void run() {
		// TODO Auto-generated method stub
		for(int i=0 ;i<6;i++)                       
		{
			System.out.println("child thread");
		}
	}
}
class test{
	myThread  t = new myThread();
	t.start();
	System.out.println("main thread");
}
-----------------------
class myThread extends Thread{
	public void start() {
		// TODO Auto-generated method stub
		for(int i=0 ;i<6;i++)                       
		{
			super.start(0);
			System.out.println("start method");
		}
	@Override
	public void run() {
		// TODO Auto-generated method stub
		for(int i=0 ;i<6;i++)                       
		{
			System.out.println("child thread");
		}
	}
}
class test{
	myThread  t = new myThread();
	t.start();
	System.out.println("main thread");
}
---------------------------------------
Thread Life Cycle:
	myThread  t = new myThread(); -----------> new/born state
	t.start();        ----------->runnable or ready state
	if Thread scheduler allocates processor -----------> running state
	if run method completes     -----------> dead state

	
	
-------------------------------------3----------------------------------------
we can define a thread by implementing runnable interface
class  Thread implements runnable{

}
Thread mythread implements runnable{

}
Runnable interface present in java.lang packageanf it contains only one method "public void run()"
class myRunnable implements Runnable{
	public void run()
	{
		for(int i=0;i<5;i++)                                     
		{ 
			System.out.println("child "+i);
		}
	}
}
public class main()
{
	public static void main(String args[])
	{
		myRunnable r = new myRunnable();
		Thread thread = new Thread(r);         ----------> Here r is target runnable
		thread.start();
	}
}
we will get mixed output andwe cant tel exact output.
case Study:
		myRunnable r = new myRunnable();
		Thread thread1 = new Thread(); 
		Thread thread2 = new Thread(r);
	case-1:thread1.start() ---->  A new thread will be created which is responsible for  the execution of thread class run(), which
	has empty implementation.
	case-2:thread1.run()  -----> No new thread will be  created and thread class run method will be executed just like a normal method call.
    case-3:thread2.start()  ----> A new thread will be created which is responsible for thr execution of myRunnable class run().
	case-4:thread2.run()  -----> A new thread wont be created and myRunnable run() will  be executed just like a normal method call.
    case-5:r.start() ----> we will get compile time error saying myRunnable class doesnt have start capability.
	    error: cannot find symbol method start() in location class runnable.
    case-6:r.run() ----> No new thread will be created and myRunnable run() will be executed like normal method call.
which approach is  best to define a thread ???
Among 2 ways of defining a thread implements runnable approach is  recommended.
In the first approach our class always extends thread class , there is no chance of extending any other class.
Hence,we are missing inheritance benefit. But in the second approach while implementing runnable interface we can extend any other class.
hence we wont miss any inheritance benefit.
Because of above reason implemeting runnable interface approach is recommended than extending thread class. 


Thread Class contructors:
  1.Thread thread = new Thread();
  2.Thread thread = new Thread(r);
  3.Thread thread = new Thread(String name);
  4.Thread thread = new Thread(Runnable r,String name);
  5.Thread thread = new Thread(ThreadGroup group,String name)
  6.Thread thread = new Thread(ThreadGroup group,Runnable r);
  7.Thread thread = new Thread(ThreadGroup group,Runnable r,String name);
  8.Thread thread = new Thread(ThreadGroup group,Runnable r,String name,Long stackSize);

Durgas approach to craete a thread(not recommended to use):

class MyThread extends Thread{
	public void run()
	{
		for(int i=0;i<5;i++)
		{
			System.out.println("childd thread"+i);
		}
	}
} 
class main{
	public static void main(String args){
		MyThread mythread = new MyThread();
		Thread t1 = new Thread(mythread);
		t1.start();
		System.out.println("main thread");

	}
}
-------mixed output---------
-------------------------4---------------------------
Getting and Setting name of a thread:
Every Thread in java has some name. It may be default name generated by JVM or customized name provided by programmer.
we can get and set name of a thread by using the following 2 methods of thread class.
public final String getName()
public final void setName(String name)
Thread.currentThread.setName("some name");
Thread.currentThread.getName();

Every Thread in java has some priority it may be default priority generated by jvm or customized priority provided by programmer.
The valid range of thread priorities is 1 to 10. Where 1 is MIN_PRIORITY and 10 is MAX_PRIORITY.
Thread class defines the following constants to represent some standard priorities.
  Thread.MIN_PRIORITY =1
  Thread.NORM_PRIORITY =5
  Thread.MAX_PRIORITY =10
Thread scheduler will use priorities while allocating processor.
The Thread which is having highest priority will get chance first.
if threads having same priority then we cant expect exact execution order.
It depends on thread scheduler.
Thread class defines the following methods to get and set priority of a thread.
public final int getPriority();
public final int setPriority(int p);
Allowed values range 1 to 10. Otherwise RunTimeException: IllegalArguementE	xception.
t.setPriority(7);  ----> valid 
t.setPriority(17);  -----> invalid  IllegalArguementException.
Default Priority: 
The default priority only for the main thread is 5.
But for all the remaining threads default priority will be inherited from parent to child.
Whatever priority parent thread has the same priority will be there for the child thread.

Example:
class mythread extends Thread{
	public void run()
	{
		for(int i=0;i<5;i++)
		{
			System.out.println("child thread"+i);
		}
	}
}
class main{
	public static void main(String args){
		MyThread mythread = new MyThread();
		Thread t1 = new Thread(mythread);
		t1.setPriority(10);
		t1.start(); 
     for(int i=0;i<5;i++)
		{
			System.out.println("main thread"+i);
		}}
in the above example child thread will be executed first because child thread has high priority(10) where as main thread has normal priority(5)
if we comment line t1.setPriority(10); then we will get mixed output.
--------------------------------------------------5555555--------------------------------------------------------
We can prevent thread execution by  using the following methods
1. yield()
2. join()
3. sleep()

1.  yield():
yield() causes to pause the current executing thread to give the chance for waiting threads of same priority.
If there is no waiting thread or  all waiting threads have low priority then same thread can continue its execution.
if multiple threads are waiting with same priority then which waiting thread will get the chance? we can't expect it depends on thread scheduler.
the thread which is yielded when it will get the chance once again it depends on thread scheduler and we cant expect exactly.
    public static native void yield();                 
	                                                     Thread.yield();
                                                 --------------------------------------
                                                |                                      | 
                          t.start()             \/           if thread scheduler       |       run() method
      new myThread();  ---------------->  ready/runnable state-------------------------> running state-------------------->   dead state
     new/born state                                        allocates processor                  completes



Example:
class mythread extends Thread{
	public void run()
	{
		for(int i=0;i<5;i++)
		{
			System.out.println("child thread"+i);
			Thread.yield();
		}
	}
}
class main{
	public static void main(String args){
		MyThread mythread = new MyThread();
		Thread t1 = new Thread(mythread);
		t1.setPriority(10);
		t1.start(); 
     for(int i=0;i<5;i++)
		{
			System.out.println("main thread"+i);
		}}
  If we are commenting Thread.yield(); the both the threads will be executed simultaneously and we cant expect whicch thread will complete first.
  If we are not commenting Thread.yield(); then child thread always calls yield method  because of that main thread will get chance more number of times
	 and the chance of completing main thread first is high.
  some platforms wont provide proper support for yield method.

2. join()
    public static void join();
  If a thread wants to wait until completing some other thread then we should go for join(). 
  For example if a thread t1 wants to wait until completing t2 then t1 has to call t2.join().
  If t1 executes t2.join() then immediately t1 will be entered into waiting state until t2 completes.
  Once t2 completes then t1 can continue its execution.
  venue fixing activiti                     wedding cards printing                           wedding cards distribution
        (t1)                                         (t2)                                               (t3)
          |                                            |                                                 | 
		  |                                            t1.join();                                        t2.join();
		                                               |                                                 |

public final void join() throws InterruptedException

public final void join(long milliseconds) throws InterruptedException

public final void join(long milliseconds,int nanoseconds) throws InterruptedException

Every join method  throws interrupted exception which is checked exception hence compulsory we should handle this exception either by using 
try catch or by throws keyword otherwise we eill get compile time error.
	                                                  
											1.	when t2 is completed
											2.	if time given for t2 expires	                 
											3.  if waiting thread got 
											    interrupted			 t2.join(); or t2.join(1000); or t2.join(1000,100);  
                                                 -------------------waiting state-------
                                                |                  blocked for joining |
												|                                      | 
                          t.start()             \/           if thread scheduler       |       run() method
      new myThread();  ---------------->  ready/runnable state----------------------> running state-------------------->   dead state
     new/born state                                        allocates processor                  completes
case 1: Waiting of main Thread until completing of child thread 

Example:
class mythread extends Thread{
	public void run()
	{
		for(int i=0;i<5;i++)
		{
			System.out.println("seetha thread"+i);
			try{
			Thread.sleep(2000);
			}catch(InterruptedException e)
			{
				e.printStackTrace();
			}
		}
	}
}
class main{
	public static void main(String args){
		MyThread mythread = new MyThread();
		Thread t1 = new Thread(mythread);
		t1.setPriority(10);
		t1.start(); 
		t1.join(); 
     for(int i=0;i<5;i++)
		{
			System.out.println("rama thread"+i);
		}}
  
If we comment t1.join() then both main and child thread will be executed simultaneously and we cannot expect exact output.
If we are not  commenting  t1.join() then main thread calls  join method on child thread object hence main thread will wait until completing child thread
in this case output is seetha thread 10 times and rama thread 10 times.

case 2:
waiting of child thread until completing main thread.


Example:
class Mythread extends Thread{
  static Thread mt;
	public void run()
	{
		
			try{
			mt.join();
			}catch(InterruptedException e)
			{
				e.printStackTrace();
			}
			 for(int i=0;i<5;i++)
		{
			System.out.println("seetha thread"+i);
		}
		}
	}
}
class main{
	public static void main(String args) throws {
		MyThread mythread = new MyThread();
		Mythread.Thread = Thread.currentThread();
		Thread t1 = new Thread(mythread);
		t1.setPriority(10);
		t1.start(); 
     for(int i=0;i<5;i++)
		{
			System.out.println("rama thread"+i);
		}}
In the above example child thread calls join method on main thread object hence child thread has to wait until completing main thread.
in this case  output is rama thread 10 times and seetha thread 10 times.

case 3:
If main thread calls join method and child thread calls join metthod on main thread object then both threads will wait forever  and the program will be 
strucked or pauesed (this is something like deadlock).
Example:
class Mythread extends Thread{
  static Thread mt;
	public void run()
	{
		
			try{
			mt.join();
			}catch(InterruptedException e)
			{
				e.printStackTrace();
			}
			 for(int i=0;i<5;i++)
		{
			System.out.println("seetha thread"+i);
		}
		}
	}
}
class main{
	public static void main(String args) throws {
		MyThread mythread = new MyThread();
		Mythread.Thread = Thread.currentThread();
		Thread t1 = new Thread(mythread);
		t1.setPriority(10);
		t1.start(); 
		t1.join();
     for(int i=0;i<5;i++)
		{
			System.out.println("rama thread"+i);
		}}
case 4: If a thread calls join() on a same thread itself then the program will be strucked. this is something like deadlock.in this case thread has to wait 
infinite amount of time.
Example:
class Test()
{
		public static void main(String args) throws  InterruptedException{
			Thread.currentThread.join();

}
